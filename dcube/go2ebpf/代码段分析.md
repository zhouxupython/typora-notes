# 代码段分析

## 复合map

复合map

```c
//注意这几个id，不是fd，fd是创建map后系统分配的一个值
//id是用户使用宏创建map时自己指定的，对系统没有意义，只是创建过程中会用到，用于指定父子关系
//父map创建完成后，其记录的数据，是子map的fd信息
struct bpfm_map_custom {
...
    /* the following parameters are used for map-in-map */
	__s32 map_id;	//就是这个map自身的id
	__s32 relation_id; /* for inner map,it means parent map id（反指父map）
                          for outer map,it means child map id（指定一个子map作为模板） */
	__s32 inner_index; /* only for inner map and key type is uint32 
                          default NO_PREPOPULATE (-1) : not prepopulate */
};

#define BMAP_BASE(map_name, map_type, k_type, v_type, max_em, pin, flag, map_idx, relation_idx, inner_idx) \
    struct bpfm_map_custom BPFM_SEC_MAPS map_name = {   \
...
        .map_id        		= map_idx,                   \
        .relation_id        = relation_idx,              \
        .inner_index        = inner_idx,                 \
    }; \
 
#不牵扯复合map时，最后三项都填成对应的默认值
#define BMAP_COM_EXT0(map_name, map_type, k_type, v_type) \
    BMAP_BASE(..., -1, -1, NO_PREPOPULATE)
 
```

复合map创建过程

```go
func (o *BpfObject) createAllMaps() error {

	if len(o.maps) == 0 {
		return nil
	}

	var err error
	outerMaps := make([]*bpfMapSpec, 0)
	innerMaps := make([]*bpfMapSpec, 0)

	for _, mapInfo := range o.maps {
		//1. 判断是不是复合map中的父map，只有父map会是这两种map类型中的一种
		if mapInfo.mapType == BPF_MAP_TYPE_ARRAY_OF_MAPS || mapInfo.mapType == BPF_MAP_TYPE_HASH_OF_MAPS {//目前支持这两种map
			outerMaps = append(outerMaps, mapInfo)
			continue//父map此刻不创建
		}
		//2. 不是父map，而且也不是 普通map，那么肯定是复合map中的子map了
		if mapInfo.relationMapID >= 0 {
            //map使用宏定义的时候，如果不是复合map，指定为 -1
			innerMaps = append(innerMaps, mapInfo)
		}
		//3. 创建子map，或者普通map，即 创建 不是map-in-map类型的map
        //所以此处cteate函数第一个参数为0
		if err = mapInfo.create(0, o.cpuCount); err != nil {
			goto __ERR
		}
	}
	
    //4. 创建父map，
    //   上面将所有子map，无论属于哪个父map，都放到innerMaps中，所以需要先区分属于哪个父map
	for _, outerInfo := range outerMaps {

		innerFd := -1
		updateMaps := make(map[int32]int)
		
        //这里就是在分类，根据用户创建map时填入的父map id（inner.relationMapID）
		for _, innerInfo := range innerMaps {
			//遍历inner，如果其mapID是用户创建map时指定的父map的relationMapID
            //那么该inner map就是模板，父map创建时需要填入，记录模板map的fd
			if innerInfo.mapID == outerInfo.relationMapID {
				innerFd = innerInfo.fd
			}
            //具体是这里在分类，寻找当前父map有哪些子map
			if innerInfo.relationMapID == outerInfo.mapID && innerInfo.innerKeyIndex >= 0 {
                //统计这个父map所有的子map的fd
				updateMaps[innerInfo.innerKeyIndex] = innerInfo.fd
			}
		}

		if innerFd < 0 {
			err = fmt.Errorf("failed to find map-in-map <%s> inner template map", outerInfo.mapName)
			goto __ERR
		}
		
        //所以此处cteate函数第一个参数为模板map的fd
		if err = outerInfo.create(innerFd, o.cpuCount); err != nil {
			goto __ERR
		}

		if outerInfo.mapType == BPF_MAP_TYPE_HASH_OF_MAPS && outerInfo.keySize != 4 {
			continue
		}
		
        //父map创建完成后，需要将其所有的子map的信息加入这个父map
        //这样父map的数据，其实就是其所以子map的fd
		for key, val := range updateMaps {
			if err = MapUpdate(outerInfo.fd, unsafe.Pointer(&key), unsafe.Pointer(&val), 0); err != nil {
				err = fmt.Errorf("failed to prepopulate map-in-map <%s> (key %d val %d err %v)", outerInfo.mapName, key, val, err)
				goto __ERR
			}
		}
	}
	return nil
__ERR:
	o.closeAllMaps()
	return err
}
```

## map加载



```go
//解析.o文件的时候，如果map还没有创建，那么先不修改指令
//先使用缓存将map的信息挂在prog上，后面等map创建好了，再修改指令
func (o *BpfObject) formatProgsInfo(raw *rawSectData) error {
...
		relos, err := raw.parseReloInfo(uint32(secInfo.idx))

    	for _, relo := range relos {
	
			insn, err := bytesToInsn(bytecodes[relo.offset:], o.ByteOrder)

			mapInfo, existed := o.maps[relo.symbol.Name]
			if mapInfo.fd <= 0 {
				cache := reloMapCache{
					insn:    insn,
					mapName: relo.symbol.Name,
					offset:  relo.offset,
				}
				newProg.cacheMaps = append(newProg.cacheMaps, cache)
			} else {
				insn.srcReg = 1
				insn.imm = uint32(mapInfo.fd)
				newBytes := insnToBytes(insn, o.ByteOrder)
				copy(bytecodes[relo.offset:], newBytes)
			}
		}
    
}    

//加载之前，会创建map，此时如果fd还是-1，那么就有问题
//正常的map会去修改指令，然后再加载
func (o *BpfObject) loadProgram(progName string, verbose bool) ([]byte, error) {

	progInfo, existed := o.progs[progName]
	
	for _, cache := range progInfo.cacheMaps {

		mapInfo, existed := o.maps[cache.mapName]

		if mapInfo.fd < 0 {
			return nil, fmt.Errorf("invalid map fd <%d> , map may not be created", mapInfo.fd)
		} else {
			cache.insn.srcReg = 1
			cache.insn.imm = uint32(mapInfo.fd)
			newBytes := insnToBytes(cache.insn, o.ByteOrder)
			copy(progInfo.insns[cache.offset:], newBytes)
		}
	}

}
```

