# 资料收集



[]()

[]()

[]()

[]()

[]()

[]()

[]()

[]()

[]()



## 不同后端的封装

Flannel可以指定不同的转发后端网络，常用的有hostgw，udp，vxlan等。

### Hostgw

hostgw是最简单的backend，它的原理非常简单，直接添加路由，将目的主机当做网关，直接路由原始封包。

例如，我们从etcd中监听到一个EventAdded事件subnet为10.1.15.0/24被分配给主机Public IP 192.168.0.100，hostgw要做的工作就是在本主机上添加一条目的地址为10.1.15.0/24，网关地址为192.168.0.100，输出设备为上文中选择的集群间交互的网卡即可。

优点：简单，直接，效率高

缺点：要求所有的pod都在一个子网中，如果跨网段就无法通信。



### UDP



![image-20220117172034535](image-20220117172034535.png)

![img](2.png)

### vxlan

![img](1060878-20190420145758804-1550036759.png)

![img](4.png)

![image-20220117171920849](image-20220117171920849.png)

【猜测】

**为何udp在内层没有mac部分？**而为何vxlan有mac部分？

感觉vxlan的mac部分是为了区分flannel虚拟网卡用的，*如果有多个flannel虚拟网卡*：

UDP：flanneld会将获取的封包（udp图中第二个ip部分和icmp部分）作为负载数据，通过udp socket发往目的主机。udp肯定指明了端口，目的主机的协议栈，会根据端口号将数据发给flanneld进程，然后转给flannel虚拟网卡。

vxlan：当目的主机收到数据后，在内核协议栈通过逐层剥离，可以发现是vxlan协议数据，就根据mac中标明的目的flannel将数据传入对应的flannel中

> 事实上，flannel只使用了vxlan的部分功能，由于VNI被固定为1，本质上工作方式和udp backend是类似的，区别无非是将udp的proxy换成了内核中的vxlan处理模块。而原始负载由三层扩展到了二层，但是这对三层网络方案flannel是没有意义的，这么做也仅仅只是为了适配vxlan的模型。





当初始化集群里，vxlan网络的初始化工作：

主机B加入flannel网络时,它会将自己的三个信息写入etcd中，分别是：subnet 10.1.16.0/24（容器采用的subnet）、Public IP 192.168.0.101（主机B的ip地址）、vtep设备flannel.1的mac地址 MAC B。

之后，主机A会得到EventAdded事件，并从中获取上文中B添加至etcd的各种信息。这个时候，主机A会在本机上添加三条信息：

（1）路由信息：指明了一条**隧道信息**，即所有通往目的地址10.1.16.0/24的封包都通过vtep设备flannel.1设备发出，发往的网关地址为10.1.16.0，即主机B中的flannel.1设备，即两个主机的vtep设备flannel.1设备进行对接。

**这条路由信息是逻辑上的隧道路由信息，并不能真正转发数据，就像有个另外的通道可以将数据直接从主机A的flannel.1设备就可以发送到主机B的flannel.1设备上。但是事实并不可以，必须都要通过真正的物理网卡才行。**

（2）fdb信息：MAC地址为MAC B（主机B隧道端flannel.1设备）的封包，都将通过vxlan发往目的地址192.168.0.101，即主机B

**这个fdb是真实的发送方式，指明的是使用物理网卡的发送，这是对隧道的承载。**

即主机A通过路由表查找，发现目的地址10.1.16.0/24的封包都可以使用隧道进行发送，隧道对端的mac地址是macB，那么**逻辑上**就可以直接封装二层包，填入macB，就可以发送了；但是物理上不能发送，需要进一步查找转发表。

然后查找转发表，转发表上有一条是MAC地址为MAC B为目的地址的，通过vxlan发往主机B的ip地址，那么就可以使用主机B的ip、mac，封装外层包，然后通过指明的物理if口发出。

（3）arp信息：网关地址10.1.16.0的地址为MAC B

