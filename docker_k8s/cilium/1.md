[Life of a Packet in Cilium：实地探索 Pod-to-Service 转发路径及 BPF 处理逻辑](http://arthurchiao.art/blog/cilium-life-of-a-packet-pod-to-service-zh/)

![cilium-pod-to-service-path](./cilium-pod-to-service-path.png)

### Step 1: POD1 eth0 发送

本来查到的dst_mac是cilium_host的mac地址，但是Cilium 通过 ==hardcode ARP 表==，将dst_mac分配给`lxc00aa`，从而强制将 Pod 流量的下一跳劫持到 veth pair 的主机端`lxc00aa`。

```bash
# Step 1: POD1 eth0 发送

(NODE1) $ nsenter-ctn POD1 -n curl 10.224.1.1:80

# 确定目的 MAC 地址
(NODE1) $ nsenter-ctn POD1 -n route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.1.1.1        0.0.0.0         UG    0      0        0 eth0
10.1.1.1        0.0.0.0         255.255.255.255 UH    0      0        0 eth0                 # 默认路由

(NODE1) $ nsenter-ctn POD1 -n arp -n
Address               HWtype  HWaddress           Flags Mask            Iface
10.1.1.1              ether   3e:74:f2:60:ab:9b   C                     eth0                 # dst_mac

# NODE1 上查看，会发现这个 MAC 其实并不是网关 cilium_host/cilium_net
(NODE1) $ ifconfig cilium_host
cilium_host: flags=4291<UP,BROADCAST,RUNNING,NOARP,MULTICAST>  mtu 1500
        inet 10.1.1.1  netmask 255.255.255.255  broadcast 0.0.0.0
        ether 3e:7d:6b:32:44:8e  txqueuelen 1000  (Ethernet)
        ...

(NODE1) $ ip link | grep 3e:74:f2:60:ab:9b -B 1
699: lxc00aa@if698: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue
    link/ether 3e:74:f2:60:ab:9b brd ff:ff:ff:ff:ff:ff link-netnsid 4               # dst_mac属于 lxc00aa 设备，index是699

# 这个 MAC 属于 lxc00aa 设备，并且从 @ 符号判断，它属于某个 veth pair 的一端，另一端的 interface index 是 698
(NODE1) $ nsenter-ctn POD1 -n ip link
698: eth0@if699: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue           # 698、699是一对veth pair
    link/ether 5e:d9:e5:0d:a1:ed brd ff:ff:ff:ff:ff:ff link-netnsid 0

# 容器的 eth0 index 就是 698，对端是 699
# Cilium 通过 hardcode ARP 表，强制将 Pod 流量的下一跳劫持到 veth pair 的主机端。这里不过多讨论设计，只说一点：这并不是 Cilium 独有的设计，其他 方案也有这么做的。
```

### Step 2: POD1 `eth0` 对端设备（`lxcxx`）BPF 处理

```bash
#查看lxc00aa加载的 BPF 程序
(NODE1) $ tc filter show dev lxc00aa ingress
filter protocol all pref 1 bpf
filter protocol all pref 1 bpf handle 0x1 bpf_lxc.o:[from-container] direct-action not_in_hw tag 3855f578c6616972

代码是：
```

```c
// bpf\bpf_lxc.c

/* Attachment/entry point is ingress for veth.
 * It corresponds to packets leaving the container.
 */
__section("from-container")
int cil_from_container(struct __ctx_buff *ctx)
  |-validate_ethertype(skb, &proto)
  |-switch (proto) {
      case ETH_P_IP:
          tail_handle_ipv4                                                     // bpf/bpf_lxc.c
            |-handle_ipv4_from_lxc                                             // bpf/bpf_lxc.c
                |-if dst is k8s Service
                |    lb4_local()
                |      |-ct_create4
                |      |-lb4_lookup_backend
                |      |-lb4_xlate
                |
                |-policy_can_egress4()
                |
                |-if tunnel
                |     encap vxlan
                | else // direct routing, pass to kernel stack (continue normal routing)
                |     ipv4_l3()                       // dec TTL, set src/dst MAC
                |     asm_set_seclabel_identity(skb); // set identity to skb
                |-return TC_ACT_OK;    

          
          lb、ct、dnat、l3封装、路由
```

### Step 3: NODE1：内核路由判断

经过 Step 2 的 `from-container` BPF 程序处理之后，**包的 `dst_ip` 已经是真实 Pod IP（`POD4_IP`）了**。

接下来就进入内核协议栈进行路由（kernel routing）。

此时内核就**相当于一台路由 器（router），查询内核路由表**，根据包的 `dst_ip` 进行路由判断，确定下一跳。

```bash
(NODE1) $ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.255.255.1    0.0.0.0         UG    0      0        0 bond0
10.1.1.0        10.1.1.1        255.255.255.0   UG    0      0        0 cilium_host
10.1.1.1        0.0.0.0         255.255.255.255 UH    0      0        0 cilium_host
```

根据以上路由规则，只要目的 IP 不是本机 PodCIDR 网段的，都会命中默认路由（第一条） ，走 `bond0` 设备。

因此包接下来会到达 `bond0` 设备。

> 本文的 node 都是两个物理网卡做了 bond，如果没有 bond，例如只有一个 eth0 物理网卡，宿主机 IP 配置在 eth0，那接下来包到达的就是 eth0 物理网卡。这种主机上配置 了 IP 地址的设备（这里是指**bond**吧？？？），在 Cilium 里叫 ==native device==。文档或代码中经常会看到。

### Step 4: NODE1 bond/物理网卡：egress BPF 处理

查看 bond 设备上的出向（egress）BPF，==这是包出宿主机之前最后的 tc BPF hook 点：==

```bash
(NODE1) $ tc filter show dev bond0 egress
filter protocol all pref 1 bpf
filter protocol all pref 1 bpf handle 0x1 bpf_netdev_bond0.o:[to-netdev] direct-action not_in_hw tag b536a7e2744a4cdb
```

```c
__section("to-netdev")
int to_netdev(struct __ctx_buff *ctx __maybe_unused)
  |-policy_clear_mark
  |-src_id = resolve_srcid_ipv4
  |   |-lookup_ip4_remote_endpoint
  |       |-ipcache_lookup4
  |-ipv4_host_policy_egress(src_id)
      |-policy_can_egress4
      |-ret = ct_lookup4()
      |-switch (ret) {
          case CT_NEW        : ct_create4(); break;
          case CT_ESTABLISHED:
          case CT_RELATED    :
          case CT_REPLY      :               break;
          default            : ret = DROP;   break;
        }
        return ret;
```

粗略地说，对于我们这个 case，这段 BPF 其实并不会做什么实际的事情，程序最后返回 `TC_ACK_OK` 放行。

> **Native device 上的 BPF 主要处理南北向流量**，即，容器和集群外交互的流量 [3]。这包括，
>
> - LoadBalancer Service 流量
> - 带 externalIPs 的 Service 流量
> - NodePort Service 流量

接下来**根据内核路由表和 ARP 表封装 L2 头**。

```bash
$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.255.255.1    0.0.0.0         UG    0      0        0 bond0
10.1.1.0        10.1.1.1        255.255.255.0   UG    0      0        0 cilium_host
10.1.1.1        0.0.0.0         255.255.255.255 UH    0      0        0 cilium_host

$ arp -n      # 宿主机网关
Address                  HWtype  HWaddress           Flags Mask            Iface
10.255.255.1             ether   00:00:5e:00:01:0c   C                     bond0
```

命中宿主机默认路由，因此会

- **将 `bond0` 的 MAC 作为 `src_mac`**：MAC 地址只在二层网络内有效，宿主机和 Pod 属于不同二层网络（Cilium 自己管理了一个 CIDR），宿主机做转发时会将 `src_mac` 换成自己的 MAC。
- **将宿主机网关对应的 MAC 作为 `dst_mac`**：下一跳是宿主机网关。

然后包就经过 bond0 和物理网卡发送到数据中心网络了。

> 可以在 `bond0` 及物理网卡上抓包验证，指定 `-e` 打印 MAC 地址。



















